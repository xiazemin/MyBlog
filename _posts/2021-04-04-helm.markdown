---
title: helm  chart
layout: post
category: k8s
author: 夏泽民
---
Chart 目录结构
examples/
  Chart.yaml          # Yaml文件，用于描述Chart的基本信息，包括名称版本等
  LICENSE             # [可选] 协议
  README.md           # [可选] 当前Chart的介绍
  values.yaml         # Chart的默认配置文件
  requirements.yaml   # [可选] 用于存放当前Chart依赖的其它Chart的说明文件
  charts/             # [可选]: 该目录中放置当前Chart依赖的其它Chart
  templates/          # [可选]: 部署文件模版目录，模版使用的值来自values.yaml和由Tiller提供的值
  templates/NOTES.txt # [可选]: 放置Chart的使用指南
<!-- more -->
templates 目录
templates目录中存放了Kubernetes部署文件的模版。


模板
Templates目录下是yaml文件的模板，遵循Go template语法。使用过Hugo的静态网站生成工具的人应该对此很熟悉。

检查配置和模板是否有效
当使用kubernetes部署应用的时候实际上讲templates渲染成最终的kubernetes能够识别的yaml格式。

使用helm install --dry-run --debug <chart_dir>命令来验证chart配置。该输出中包含了模板的变量配置与最终渲染的yaml文件。

部署到kubernetes
在mychart目录下执行下面的命令将nginx部署到kubernetes集群上。

helm install .

https://www.jianshu.com/p/aff467690d57

在云 (Kubernetes)上，部署一个应用往往却不是那么简单。如果想要部署一个应用程序到云上，首先要准备好它所需要的环境，打包成 Docker 镜像，进而把镜像放在部署文件 (Deployment) 中、配置服务 (Service)、应用所需的账户 (ServiceAccount) 及权限 (Role)、命名空间 (Namespace)、密钥信息 (Secret)、可持久化存储 (PersistentVolumes) 等资源。也就是编写一系列互相相关的 YAML 配置文件，将它们部署在 Kubernetes 集群上。

但是即便应用的开发者可以把这些 Docker 镜像存放在公共仓库中，并且将所需的 YAML 资源文件提供给用户，用户仍然需要自己去寻找这些资源文件，并把它们一一部署。倘若用户希望修改开发者提供的默认资源，比如使用更多的副本 (Replicas) 或是修改服务端口 (Port)，他还需要自己去查需要在这些资源文件的哪些地方修改，更不用提版本变更与维护会给开发者和用户造成多少麻烦了。

有一系列基于 Kubernetes 的应用包管理工具横空出世。而我们今天的主角 Helm，就是这其中最受欢迎的选择之一。

开发者按照 Helm Chart 的格式，将应用所需的资源文件包装起来，通过模版化 (Templating) 的方式将一些可变字段（比如我们之前提到的暴露哪个端口、使用多少副本）暴露给用户，最后将封装好的应用包，也就是 Helm Chart，集中存放在统一的仓库中供用户浏览下载。

站在用户角度，用户只需要一行简单的命令就可以完成应用的安装、卸载与升级。对于安装之后状态，也可以通过 helm list 或者是原生的 kubectl 进行查询。




